---
KIP: '0030'
Title: SpirekeyConnect
Author: Andy Tang @EnoF
Status: Draft
Type: Standard
Category: Interface
Created: 2024-01-22
---

# Abstract

We propose to use a different way for dApps to connect with Wallets using
existing and proven Web2 Standards in order to improve the usability for end
users interacting with dApps and Wallets.

# Motivation

As of writing there are several ways to connect a dApp to a Wallet in order to
sign for transactions. We believe that the available setups do not provide for
the seamless connection we ambition for.

On the Web2 space there are well established techniques to provide authorization
over multiple domains. One well known and widely used technique is OAuth. Users
use this often in a seemless way and often provides for a lower level of entry
in the registration process.

Our belief is that the wallets could serve as the new decentralized hub of
authorization and authentication that centralized services like Google, Twitter
and Facebook offer now. Utilizing a Wallet with this proposed solution should
reduce the friction for users to interact with the services offered and increase
conversion rate.

# Specifications

Wallets and dApps will communicate with the end user's browser via `https`. All
the information will be relayed via the end user's browser. In this
specification there will be the following points of interest:

1. Notifications
2. Connect
3. Sign

In this specification `typescript` will be used to describe the data structures
expected in the communication between the Wallet and the dApp. Note that if you
wish to use different languages, you are free to do so, so long as the data is
send to the dApp in the same format accepted by `postMessage` listeners.

## Notifications

In order to provide a seamless experience for the user, the Wallet needs to
provide a page to be embedded in the dApp in the form of an iframe. This iframe
will be used to indicate to the user that the Wallet is processing a request.
The Wallet can use this iframe to display a loading indicator in the style of
the Wallet. The iFrame is expected to be hosted on the Wallet's domain on the
path `/embedded/notification`.

The SDK can provide the notification frame pending transactions for the Wallet
to handle. This will be provided via the hash parameter `accounts`. The wallet
can make use of the `txQueue` field in the `Account` object to determine which
transactions are pending and handle them accordingly.

## Connect

The dApp will provide a button to connect to the Wallet. The SpireKey SDK will
display a notification another window has activity. This allows the wallet to be
opened in a new window and and ask the user to connect to the dApp. The Wallet
will be opened on the path `/connect`.

The dApp can provide additional parameters to the Wallet by adding them to the
URL in the form of hash parameters. The parameters will be used to provide
additional context to the Wallet in which the dApp expects to operate. The
parameters are: `chainId` and `networkId`.

The Wallet is responsible for connecting existing accounts or help the user to
create a new account. How the user is guided through this process is up to the
Wallet.

After the user has connected a new account or selected an existing account, the
Wallet should emit an `postMessage` event on the `window` of the Wallet. In the
message the Wallet should include the following information:

```ts
type ConnectEventPayload = {
  source: 'kadena-spirekey';
  name: 'connected';
  payload: Account;
};
```

If the user cancels the connection process, the Wallet should close the window
and emit an event with the following information:

```ts
type CanceledConnectEventPayload = {
  source: 'kadena-spirekey';
  name: 'canceled:connect';
  payload: void;
};
```

## Sign

The dApp will provide a button to sign a transaction. The SpireKey SDK will
display a notification another window has activity. This allows the wallet to be
opened in a new window and and ask the user to sign the transaction. The Wallet
will be opened on the path `/sign`. The Wallet is responsible for displaying the
transaction to the user and ask for the user's approval. How the user is guided
through this process is up to the Wallet.

The dApp will send a list of transactions to the Wallet and optionally a list of
accounts that need to have fungibles avaible for the transaction. The Wallet can
use this information to help the user funnel the funds to the requested chain.

The parameters will be send to the Wallet in the form of hash parameters. The
parameters are: `transactions` and `accounts`. The `transactions` parameter is
expected to be a JSON encoded array of transactions. The `accounts` parameter is
expected to be a JSON encoded array of `OptimalTransactionsAccount` which is a
subset of an `Account`.

After the user has signed for all necessary transactions, the Wallet should
submit any transactions that are needed to funnel the funds to the requested
chain. The TransactionDescriptors for those transactions should be included in
the `postMessage` event.

After the user has signed for all necessary transactions, the Wallet should emit
an `postMessage` event on the `window` of the Wallet. In the message the Wallet
should include the following information:

```ts
type SignEventPayload = {
  source: 'kadena-spirekey';
  name: 'signed';
  payload: {
    accounts: Account[];
    txs: Record<string, { sig: string; pubKey: string }[]>;
  };
};
```

If the user cancels the sign process, the Wallet should close the window and
emit an event with the following information:

```ts
type CanceledSignEventPayload = {
  source: 'kadena-spirekey';
  name: 'canceled:sign';
  payload: void;
};
```

## Type References

### ConnectEventPayload

```ts
type ConnectEventPayload = {
  source: 'kadena-spirekey';
  name: 'connected';
  payload: Account;
};
```

### Account

```ts
import type { ChainId, ITransactionDescriptor } from '@kadena/client';

export type QueuedTx = ITransactionDescriptor;

export type OptimalTransactionsAccount = Pick<
  Account,
  'chainIds' | 'accountName' | 'networkId' | 'requestedFungibles'
>;
export type Account = {
  alias: string;
  accountName: string;
  minApprovals: number;
  minRegistrationApprovals: number;
  balance: string;
  devices: Device[];
  guard?: Guard;
  keyset?: Keyset;
  networkId: string;
  chainIds: ChainId[];
  txQueue: QueuedTx[];
  requestedFungibles?: RequestedFungible[];
};

export type Device = {
  domain: string;
  color: string;
  deviceType: string;
  ['credential-id']: string;
  guard: Keyset;
  pendingRegistrationTxs?: ITransactionDescriptor[];
  name?: string;
};

export type Guard = RefKeyset | Keyset;
type RefKeyset = {
  keysetref: {
    ns: string;
    ksn: string;
  };
};
type Keyset = {
  keys: string[];
  pred: string;
};

export type RequestedFungible = {
  fungible: string;
  amount: number;
  target?: ChainId;
};
```
