{"version":3,"file":"object.js","sourceRoot":"","sources":["../../../src/utils/object.ts"],"names":[],"mappings":";;;AAAA,6BAA0C;AAmB1C,SAAgB,aAAa,CAG3B,MAAS,EAAE,eAAkC,EAAE;IAC/C,OAAO,mBAAmB,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AACnD,CAAC;AALD,sCAKC;AAGD,SAAS,mBAAmB,CAC1B,MAA+B,EAC/B,eAAkC,EAAE,EACpC,MAAe;IAEf,IAAI,IAAA,aAAQ,EAAC,MAAM,CAAC,EAAE;QACpB,OAAO,EAAE,CAAC,MAAO,CAAC,EAAE,MAAM,EAAS,CAAC;KACrC;IACD,MAAM,eAAe,GAAQ,EAAE,CAAC;IAChC,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;QACxB,IAAI,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YAC9B,SAAS;SACV;QACD,MAAM,MAAM,GAAG,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QACpE,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;QACzB,IAAI,IAAA,aAAQ,EAAC,IAAI,CAAC,EAAE;YAClB,MAAM,CAAC,MAAM,CACX,eAAe,EACf,mBAAmB,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,CAAC,CAChD,CAAC;SACH;aAAM;YACL,eAAe,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;SAChC;KACF;IACD,OAAO,eAAe,CAAC;AACzB,CAAC","sourcesContent":["import { isObject, isString } from './is';\n\nexport type ObjectPathLeaves<T, Ignored = never> = T extends object\n  ? {\n      [K in keyof T]: `${Exclude<K, symbol | Ignored>}${T[K] extends object\n        ? `.${ObjectPathLeaves<T[K], Ignored>}`\n        : ''}`;\n    }[keyof T]\n  : never;\n\nexport type FlattenObject<T extends object, Ignored = never> = {\n  [Key in ObjectPathLeaves<T, Ignored>]: string;\n};\n\n/**\n * Flattens an object to a single level object with dot notation\n * @param {Record<string, any>} tokens - The tokens to flatten\n * @param {string[]} ignoredPaths - The paths to ignore\n */\nexport function flattenObject<\n  T extends Record<string, unknown>,\n  Ignored = never,\n>(tokens: T, ignoredPaths: readonly string[] = []): FlattenObject<T, Ignored> {\n  return flattenObjectHelper(tokens, ignoredPaths);\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nfunction flattenObjectHelper(\n  tokens: Record<string, unknown>,\n  ignoredPaths: readonly string[] = [],\n  prefix?: string,\n) {\n  if (isString(tokens)) {\n    return { [prefix!]: tokens } as any;\n  }\n  const flattenedTokens: any = {};\n  for (const key in tokens) {\n    if (ignoredPaths.includes(key)) {\n      continue;\n    }\n    const newKey = prefix !== undefined ? prefix.concat('.', key) : key;\n    const item = tokens[key];\n    if (isObject(item)) {\n      Object.assign(\n        flattenedTokens,\n        flattenObjectHelper(item, ignoredPaths, newKey),\n      );\n    } else {\n      flattenedTokens[newKey] = item;\n    }\n  }\n  return flattenedTokens;\n}\n"]}